<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>War Game Online - ロビー</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; }
    #kantoUiRoot { margin-top: 12px; }
    .game-ui-wrap {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      align-items: start;
    }
    @media (max-width: 900px) {
      .game-ui-wrap { grid-template-columns: 1fr; }
    }
    details { margin-top: 12px; }
    pre { white-space: pre-wrap; background:#eef; padding:8px; max-height: 400px; overflow:auto; }
  </style>
</head>

<body>
  <h1>War Game Online - オンラインロビー</h1>

  <section>
    <h2>ロビー / 自動マッチング（8人 または 3分で開始）</h2>
    <p>
      ロビーに参加すると、<strong>参加人数が8人に達する</strong>か、
      <strong>最初のプレイヤーが入室してから3分経過</strong>したタイミングで
      自動的にマッチングされます。
    </p>

    <div style="margin-top: 8px;">
      <label>
        プレイヤー名（ロビー用）:
        <input id="lobbyPlayerNameInput" type="text" placeholder="例: あああ" />
      </label>
      <button id="joinLobbyBtn">ロビーに参加（キューに入る）</button>
    </div>

    <div style="margin-top: 8px;">
      <p>自分のロビー用 UID: <span id="myLobbyUidSpan">(未生成)</span></p>
      <p>ロビー状態: <span id="lobbyStatusSpan">-</span></p>
      <p>マッチ開始まで: <span id="lobbyTimerSpan">-</span></p>
      <p>現在の人数: <span id="lobbyCountSpan">0</span> / 8</p>
    </div>

    <div style="margin-top: 8px;">
      <h3>ロビー内プレイヤー一覧（matching/waitingRoom）</h3>
      <ul id="lobbyPlayersList">
        <li>(まだ誰もいません)</li>
      </ul>
    </div>

    <div style="margin-top: 8px;">
      <p>ロビー制マッチでの自分のプレイヤー番号: <span id="myLobbyIndexSpan">-</span></p>
      <p>ロビー制マッチで割り当てられた gameId: <span id="myLobbyGameIdSpan">(まだなし)</span></p>
    </div>
  </section>

  <!-- ゲーム本体表示エリア -->
  <section id="gameSection" style="margin-top: 24px; border-top: 1px solid #ccc; padding-top: 16px; display: none;">
    <h2>対戦中ゲーム</h2>
    <p>gameId: <span id="gameIdSpan">(未割り当て)</span></p>
    <p>currentTurn: <span id="gameCurrentTurnSpan">-</span></p>
    <p>ゲーム状態: <span id="gamePhaseSpan">-</span></p>

    <div style="margin-top: 8px;">
      <button id="readyButton">このターンの準備完了（submitTurn）</button>
    </div>

    <!-- ★ 地図UIの差し込み先 -->
    <div id="kantoUiRoot"></div>

    <!-- ★ デバッグ用：JSON 表示は details に退避 -->
    <details>
      <summary>デバッグ：ゲーム内部状態（state JSON）</summary>
      <p style="font-size: 0.9em;">
        UI作成中の確認用です。慣れたら閉じたままでもOK。
      </p>
      <pre id="gameStatePre"></pre>
    </details>
  </section>

  <script type="module">
    import {
      joinMatchQueue,
      subscribeWaitingRoom,
      subscribeMyGame,
      subscribeGame,
      submitTurn as submitTurnApi,
      callForceLobbyMatch,
    } from "./src/matching.js";

    // ★ 追加：関東UI
    import { createKantoUi } from "./src/ui/kanto_ui.js";

    // ===== ロビー用 DOM =====
    const lobbyPlayerNameInput = document.getElementById("lobbyPlayerNameInput");
    const joinLobbyBtn = document.getElementById("joinLobbyBtn");
    const myLobbyUidSpan = document.getElementById("myLobbyUidSpan");
    const lobbyStatusSpan = document.getElementById("lobbyStatusSpan");
    const lobbyTimerSpan = document.getElementById("lobbyTimerSpan");
    const lobbyCountSpan = document.getElementById("lobbyCountSpan");
    const lobbyPlayersList = document.getElementById("lobbyPlayersList");
    const myLobbyIndexSpan = document.getElementById("myLobbyIndexSpan");
    const myLobbyGameIdSpan = document.getElementById("myLobbyGameIdSpan");

    // ===== ゲーム用 DOM =====
    const gameSection = document.getElementById("gameSection");
    const gameIdSpan = document.getElementById("gameIdSpan");
    const gameCurrentTurnSpan = document.getElementById("gameCurrentTurnSpan");
    const gamePhaseSpan = document.getElementById("gamePhaseSpan");
    const gameStatePre = document.getElementById("gameStatePre");
    const readyButton = document.getElementById("readyButton");

    // ===== ★ 地図UI初期化 =====
    const kantoUiRoot = document.getElementById("kantoUiRoot");
    const kantoUi = createKantoUi({
      rootEl: kantoUiRoot,
      // public/assets/kanto.png を使う前提（Viteなら /assets/... で配信されます）
      mapImageUrl: "assets/kanto.png",
    });

    // ===== ロビー用 UID をローカルに保持 =====
    const LOBBY_UID_KEY = "wgo_lobby_uid_v1";
    let lobbyUid = localStorage.getItem(LOBBY_UID_KEY);
    if (!lobbyUid) {
      lobbyUid =
        (window.crypto &&
          window.crypto.randomUUID &&
          window.crypto.randomUUID()) ||
        "uid-" + Math.random().toString(36).slice(2);
      localStorage.setItem(LOBBY_UID_KEY, lobbyUid);
    }
    myLobbyUidSpan.textContent = lobbyUid;

    // ===== カウントダウン用の状態 =====
    let firstJoinedMs = null;
    let timerId = null;
    let hasRequestedForceMatch = false;

    function formatJoinedTime(ms) {
      const d = new Date(ms);
      return d.toLocaleTimeString("ja-JP", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      });
    }

    function updateTimer() {
      if (firstJoinedMs == null) {
        lobbyTimerSpan.textContent = "-";
        return;
      }

      const TOTAL_MS = 3 * 60 * 1000;
      const elapsed = Date.now() - firstJoinedMs;
      const remaining = TOTAL_MS - elapsed;

      if (remaining <= 0) {
        lobbyTimerSpan.textContent = "3分経過（サーバー側でマッチング判定中…）";
        if (!hasRequestedForceMatch) {
          hasRequestedForceMatch = true;
          callForceLobbyMatch();
        }
        return;
      }

      const sec = Math.floor(remaining / 1000);
      const min = Math.floor(sec / 60);
      const s = sec % 60;
      lobbyTimerSpan.textContent =
        `${min}:${String(s).padStart(2, "0")} 後に自動マッチング（1人目参加から）`;
    }

    function startTimerIfNeeded() {
      if (!timerId) {
        timerId = setInterval(updateTimer, 1000);
      }
      updateTimer();
    }

    function stopTimer() {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
      firstJoinedMs = null;
      lobbyTimerSpan.textContent = "-";
    }

    // ===== ロビー状態を購読 =====
    subscribeWaitingRoom((data) => {
      const players = Array.isArray(data.players) ? data.players : [];
      lobbyCountSpan.textContent = String(players.length);

      const sorted = [...players].sort((a, b) => {
        const ta = typeof a.joinedAt === "number" ? a.joinedAt : Number.MAX_SAFE_INTEGER;
        const tb = typeof b.joinedAt === "number" ? b.joinedAt : Number.MAX_SAFE_INTEGER;
        return ta - tb;
      });

      const validTimes = sorted
        .map((p) => (typeof p.joinedAt === "number" ? p.joinedAt : null))
        .filter((v) => v != null);

      if (validTimes.length > 0) {
        const newFirst = Math.min(...validTimes);
        if (firstJoinedMs === null || newFirst !== firstJoinedMs) {
          firstJoinedMs = newFirst;
          hasRequestedForceMatch = false;
        }
        startTimerIfNeeded();
        lobbyStatusSpan.textContent = "ロビー待機中…";
      } else {
        stopTimer();
        hasRequestedForceMatch = false;
        lobbyStatusSpan.textContent = "プレイヤー待機中…";
      }

      lobbyPlayersList.innerHTML = "";
      if (sorted.length === 0) {
        const li = document.createElement("li");
        li.textContent = "(まだ誰もいません)";
        lobbyPlayersList.appendChild(li);
      } else {
        sorted.forEach((p) => {
          const li = document.createElement("li");
          const isMe = p.uid === lobbyUid;

          let timeLabel = "[時刻不明]";
          if (typeof p.joinedAt === "number") {
            timeLabel = "[" + formatJoinedTime(p.joinedAt) + "]";
          }

          li.textContent = `${p.name ?? "NoName"} ${timeLabel}` + (isMe ? " ← あなた" : "");
          lobbyPlayersList.appendChild(li);
        });
      }

      const myIndex = sorted.findIndex((p) => p.uid === lobbyUid);
      myLobbyIndexSpan.textContent = myIndex >= 0 ? String(myIndex + 1) : "-";
    });

    // ===== ゲーム購読用の状態 =====
    let currentGameId = null;
    let myPlayerIndex = null;
    let unsubscribeGame = null;
    let latestGameData = null;

    // 自分に割り当てられた gameId を監視
    subscribeMyGame(lobbyUid, (game) => {
      if (!game) {
        myLobbyGameIdSpan.textContent = "(まだなし)";
        gameSection.style.display = "none";
        gameIdSpan.textContent = "(未割り当て)";
        gameCurrentTurnSpan.textContent = "-";
        gamePhaseSpan.textContent = "-";
        gameStatePre.textContent = "";
        currentGameId = null;
        myPlayerIndex = null;
        latestGameData = null;

        if (unsubscribeGame) {
          unsubscribeGame();
          unsubscribeGame = null;
        }

        // ★ UI側もリセット
        kantoUi.reset();
        return;
      }

      currentGameId = game.id;
      myLobbyGameIdSpan.textContent = currentGameId;
      gameIdSpan.textContent = currentGameId;
      gameSection.style.display = "block";

      // プレイヤー番号 (0-origin)
      if (Array.isArray(game.playerIds)) {
        const idx = game.playerIds.indexOf(lobbyUid);
        myPlayerIndex = idx >= 0 ? idx : 0;
      } else {
        myPlayerIndex = 0;
      }

      // ★ UIにコンテキストを渡す（gameId / 自分の番号）
      kantoUi.setContext({
        gameId: currentGameId,
        myPlayerIndex,
      });

      if (unsubscribeGame) {
        unsubscribeGame();
        unsubscribeGame = null;
      }

      unsubscribeGame = subscribeGame(currentGameId, (g) => {
        if (!g) {
          gameCurrentTurnSpan.textContent = "-";
          gamePhaseSpan.textContent = "-";
          gameStatePre.textContent = "(ゲームドキュメントが存在しません)";
          latestGameData = null;
          kantoUi.setGameDoc(null);
          return;
        }

        latestGameData = g;

        const currentTurn =
          g.currentTurn != null
            ? g.currentTurn
            : g.state && g.state.turn != null
            ? g.state.turn
            : null;
        gameCurrentTurnSpan.textContent = currentTurn != null ? String(currentTurn) : "-";

        const phase =
          g.phase ??
          (g.state && (g.state.phase || g.state.stage || g.state.status || null));
        gamePhaseSpan.textContent = phase != null ? String(phase) : "-";

        // ★ UIにゲームデータを渡す（ここが本命）
        kantoUi.setGameDoc(g);

        // デバッグ表示は残す
        if (g.state) {
          gameStatePre.textContent = JSON.stringify(g.state, null, 2);
        } else {
          gameStatePre.textContent = "(state がまだありません)";
        }
      });
    });

    // ===== 「このターンの準備完了」ボタン =====
    readyButton.addEventListener("click", async () => {
      if (!currentGameId) {
        alert("まだ gameId が割り当てられていません。マッチング完了を待ってください。");
        return;
      }
      if (myPlayerIndex == null) {
        alert("自分のプレイヤー番号が未確定です。少し待ってから再度お試しください。");
        return;
      }

      const originalLabel = readyButton.textContent;
      readyButton.disabled = true;
      readyButton.textContent = "送信中...";

      try {
        // ★ UIが作った actions を送る（当面、UIが空配列でもOK）
        const actions = kantoUi.getActionsForSubmit();
        const res = await submitTurnApi(currentGameId, myPlayerIndex, actions);

        const newTurn = (res && res.currentTurn != null) ? String(res.currentTurn) : "(不明)";
        alert("このターンの行動を送信しました。currentTurn = " + newTurn);

        // 送信したらキューを消す（好みで）
        kantoUi.clearPendingActions();
      } catch (err) {
        console.error(err);
        alert("submitTurn でエラーが発生しました: " + String(err));
      } finally {
        readyButton.disabled = false;
        readyButton.textContent = originalLabel;
      }
    });

    // ===== 「ロビーに参加」ボタン =====
    joinLobbyBtn.addEventListener("click", async () => {
      const name = lobbyPlayerNameInput.value.trim();
      if (!name) {
        alert("プレイヤー名を入力してください。");
        return;
      }

      lobbyStatusSpan.textContent = "ロビー参加リクエスト送信中…";

      try {
        await joinMatchQueue({
          uid: lobbyUid,
          displayName: name,
        });
        lobbyStatusSpan.textContent = "ロビー参加 OK（待機中）";
      } catch (err) {
        console.error(err);
        lobbyStatusSpan.textContent = "ロビー参加エラー: " + String(err);
        alert("ロビーへの参加中にエラーが発生しました。コンソールを確認してください。");
      }
    });
  </script>
</body>
</html>
